% Dr. Barys Shyrokau
% Template for homework assignment #3
% RO47017 Vehicle Dynamics & Control
% Use and distribution of this material outside the RO47017 course 
% only with the permission of the course coordinator

clc; clear all; close all; clear mex;

% controller settings
Ts = 0.01;	% controller frequency

% vehicle parameters (bicycle model)
veh_parameters;

%% ACADO set up 
DifferentialState vx vy r yaw Xp Yp delta; % definition of controller states
Control d_delta; % definition of controller input
% controller model of the plant
alpha_rear = -atan((vy - par.l_r .* r)/ vx)+1e-14;
alpha_front = -atan(((vy + par.l_f * r) .* cos(delta) - vx .* sin(delta))/ ...
                     ((vy + par.l_f * r) .* sin(delta) + vx .* cos(delta)))+1e-14;
% alpha_front = delta - (vy+1e-11+par.l_f*r)/vx + 1e-11;

lambda_rear = par.mu * par.Fz / ...
            (2 * sqrt((par.Caf * tan(alpha_rear))^2)+1e-14);
lambda_front = par.mu * par.Fz / ...
             (2 .* sqrt((par.Car .* tan(alpha_front))^2) + 1e-14);

choose_rear = 1 ./ (1+exp(-(lambda_rear-1)*1000));
choose_front = 1 ./ (1+exp(-(lambda_front-1)*1000));

Calpha_front = par.Caf * ( ...
     choose_front .* 1 + (1-choose_front).*(lambda_front .* (2 - lambda_front)));
Calpha_rear = par.Car * ( ...
     choose_rear .* 1 + (1-choose_rear).*(lambda_rear .* (2 - lambda_rear)));


Fxf = 0;
Fxr = 0;
% Calpha_front = par.Caf;
% Calpha_rear = par.Car;

f_ctrl = [
    dot(vx)  == (Fxf * cos(delta) *...
              -Calpha_front * (delta - (vy + par.l_f * r)/vx) * sin(delta) ...
              +Fxr)* 1/par.mass + vy * r;...
    dot(vy) == (Fxf * sin(delta)...
        + Calpha_front * (delta - (vy + par.l_f*r)/vx) * cos(delta) ...
        - Calpha_rear * (vy - par.l_r * r)/vx) * 1/par.mass - vx*r;...
    dot(r) == (Fxf * sin(delta) + ...
        + Calpha_front * (delta - (vy + par.l_f * r)/vx) * cos(delta)) * par.l_f / par.Izz ...
        + (Calpha_rear * (vy - par.l_r*r)/vx) * par.l_r / par.Izz;...
    dot(yaw) == r;...
    dot(Xp)  == vx * cos(yaw) - vy*sin(yaw);...
    dot(Yp)  == vx * sin(yaw) + vy*cos(yaw);...
    dot(delta) == d_delta];

%% ACADO: controller formulation
acadoSet('problemname', 'PF_problem');
Np = 40;                                  % prediction horizon
ocp  = acado.OCP( 0.0, Np*Ts, Np);        % ACADO ocp

% Residual function definition based on ACADO
h = [diffStates ; controls];
hN = [diffStates];                       % terminal

% Initialization weights
W = acado.BMatrix(eye(length(h)));
WN = acado.BMatrix(eye(length(hN)));     % terminal

% Cost definition
ocp.minimizeLSQ(W,h);
ocp.minimizeLSQEndTerm(WN,hN);           % terminal

% Constraints definition
delta_thd   = 2.76*360/180*pi / par.i_steer;	 % absolute steering position
dotdelta_thd = 800*pi/(180 * par.i_steer);
sideslip = 5*pi/180;
sidesliprate = 25*pi/180;
lat_acc = 0.85*par.g*0.9;

% constraints in ACADO
ocp.subjectTo(0 <= vx <= 170/3.6);                          % longitudinal velocity
ocp.subjectTo(-sideslip <= vy/vx <= sideslip);              % sideslip angle
ocp.subjectTo(-sidesliprate <= dot(vy)/vx <= sidesliprate); % sideslip angle rate
ocp.subjectTo(-lat_acc <= dot(vy) + vx*r <= lat_acc);       % lateral acceleration
ocp.subjectTo( -delta_thd   <= delta    <= delta_thd);      % steering wheel angle
ocp.subjectTo( -dotdelta_thd <= d_delta <= dotdelta_thd);   % steering wheel velocity

% define ACADO prediction model
ocp.setModel(f_ctrl);
    
% ACADO settings [Don't change these settings in your HMA]
mpc = acado.OCPexport( ocp );
mpc.set('HESSIAN_APPROXIMATION', 'GAUSS_NEWTON');       % solving algorithm
mpc.set('DISCRETIZATION_TYPE', 'MULTIPLE_SHOOTING');    % discretization algorithm
mpc.set('INTEGRATOR_TYPE', 'INT_IRK_GL2');              % intergation algorithm
mpc.set('NUM_INTEGRATOR_STEPS', 3*Np);                  % number of integration steps
mpc.set('LEVENBERG_MARQUARDT', 1e-4);                   % value for Levenberg-Marquardt regularization -> affects performance
mpc.set('SPARSE_QP_SOLUTION', 'FULL_CONDENSING_N2');
mpc.set('QP_SOLVER', 'QP_QPOASES3');
mpc.set('MAX_NUM_QP_ITERATIONS', 20) ;
mpc.set('HOTSTART_QP','YES');
mpc.set('GENERATE_SIMULINK_INTERFACE', 'YES');

%% Export and Compile flags
EXPORT  = 1;
COMPILE = 1;

% export code to the defined folder
if EXPORT
    mpc.exportCode('export_MPC');
end

% compilation of the S-function using autogenerated make script
if COMPILE
    global ACADO_;
    copyfile([ACADO_.pwd '/../../external_packages/qpoases3'], 'export_MPC/qpoases3')
    cd export_MPC
    make_acado_solver_sfunction
    copyfile('acado_solver_sfun.mex*', '../')
    cd ..
end

%% initial MPC settings
disp('Initialization')
X0       = [V_ref 0 0 0 0 0 0];             % initial state conditions
[y_ref, Psi_ref, Psi_dot_ref]= reference_function();
% initialize controller bus
input.x  = repmat(X0, Np + 1, 1).';      % size Np + 1
input.od = zeros(Np + 1, 1);            % size Np + 1
Uref     = zeros(Np, 1);
input.u  = Uref.';
input.y  = [repmat(X0, Np, 1) Uref].';   % reference trajectory, size Np + 1
input.yN = X0.';                        % terminal reference, size Np + 1
% redefined in Simulink
input.W  = diag([0 0 0 5e-3 1e-1 0 0 0]);     % weight tuning !! Tune them in the Simulink model !!
input.WN = diag([0 0 0 0 0 0 0]);             % terminal weight tuning
input.x0 = X0.';
% controller bus initialization
init.x   = input.x(:).';                  % state trajectory
init.u   = input.u(:).';                  % control trajectory
init.y   = input.y(:).';                  % reference trajectory (up to Np - 1)
init.yN  = input.yN(:).';                % terminal reference value (only for Np)
init.W   = input.W(:).';                  % stage cost matrix (up to Np - 1)
init.WN  = input.WN(:).';                % terminal cost matrix (only for Np)
init.x0  = input.x0(:).';                % initial state value

%% simulate
sim("Nonlinear_Bicycle_Model.slx")

%% calculate and reshape 
t=t(1:10:end);
RWA=RWA(1:10:end);
x_real=V_ref*t;
y_ref=reshape(y_ref(1,1,:),[size(y_ref,3),1]);
psi_ref=reshape(psi_ref(1,1,:),[size(psi_ref,3),1]);
psi_dot_ref=reshape(psi_dot_ref(1,1,:),[size(psi_dot_ref,3),1]);
RWA2=reshape(RWA(1,1,:),[size(RWA,3),1]);
dRWA2=reshape(dRWA(1,1,:),[size(dRWA,3),1]);
y2=y;
psi2=psi;
psi_dot2=psi_dot;

ti=10;
%tf=6.2;
x_obst = 30 + V_ref*ti;

overshoot2=(max(y)-2.8)/2.5*100;
settling_time2=t(find(abs(y-y_ref)>=0.02*2.5,1,'last'))-ti;
rise_time2=t(find(y>=0.9*2.5+0.3,1,'first'))-t(find(y>=0.1*2.5+0.3,1,'first'));
RMSEy2=sqrt(mean((y(t>=ti)-y_ref(t>=ti)).^2));   % we need to find "ti", which is the time of starting manoeuvre
RMSEpsi2=sqrt(mean((psi(t>=ti)-psi_ref(t>=ti)).^2));
RMSEpsi_dot2=sqrt(mean((psi_dot(t>=ti)-psi_dot_ref(t>=ti)).^2));
%DTC=y(abs(t-tf)<1e-5)-2*0.92;   % we need to find "tf", which is the time of end manoeuvre
DTC2=min(sqrt((x_real+par.l_f-x_obst).^2+(y-2*0.92).^2));

save("nonlinear")